import SwiftUI
import Charts
import Darwin

struct ServerDetailView: View {
    let server: ClashServer
    @StateObject private var networkMonitor = NetworkMonitor()
    @State private var selectedTab = 0
    @Environment(\.dismiss) private var dismiss
    @StateObject private var viewModel = ServerDetailViewModel()
    @StateObject private var settingsViewModel = SettingsViewModel()
    @State private var showingModeChangeSuccess = false
    @State private var lastChangedMode = ""
    @State private var showingConfigSubscription = false
    @State private var showingSwitchConfig = false
    @State private var showingCustomRules = false
    @State private var showingRestartService = false
    @EnvironmentObject private var bindingManager: WiFiBindingManager
    @StateObject private var subscriptionManager: SubscriptionManager
    @StateObject private var connectivityViewModel = ConnectivityViewModel()
    @AppStorage("useFloatingTabs") private var useFloatingTabs = false
    @State private var isTabBarVisible = true
    @State private var lastScrollOffset: CGFloat = 0
    
    init(server: ClashServer) {
        self.server = server
        self._subscriptionManager = StateObject(wrappedValue: SubscriptionManager(server: server))
        
        // ËÆæÁΩÆ UITabBar ÁöÑÂ§ñËßÇ (‰ªÖÂú®‰∏ç‰ΩøÁî®ÊµÆÂä®Ê†áÁ≠æÈ°µÊó∂)
        let appearance = UITabBarAppearance()
        appearance.configureWithOpaqueBackground()
        appearance.backgroundColor = UIColor.systemBackground
        
        UITabBar.appearance().scrollEdgeAppearance = appearance
        UITabBar.appearance().standardAppearance = appearance
    }
    
    var body: some View {
        if useFloatingTabs {
            floatingTabsView
        } else {
            fixedTabsView
        }
    }
    
    @ViewBuilder
    private var floatingTabsView: some View {
        GeometryReader { geometry in
            ZStack {
                // ËÉåÊôØÂÜÖÂÆπ
                Group {
                    switch selectedTab {
                    case 0:
                        OverviewTab(
                            server: server, 
                            monitor: networkMonitor, 
                            selectedTab: $selectedTab, 
                            settingsViewModel: settingsViewModel,
                            connectivityViewModel: connectivityViewModel
                        )
                        .onAppear {
                            HapticManager.shared.impact(.light)
                            settingsViewModel.fetchConfig(server: server) 
                            connectivityViewModel.setupWithServer(server, httpPort: settingsViewModel.httpPort, settingsViewModel: settingsViewModel)
                            // print("‚öôÔ∏è ServerDetailView - ÂàùÂßãÊúçÂä°Âô®ËÆæÁΩÆ, Á´ØÂè£: \(settingsViewModel.httpPort)")
                        }
                    case 1:
                        ProxyView(server: server)
                            .onAppear {
                                HapticManager.shared.impact(.light)
                            }
                    case 2:
                        RulesView(server: server)
                            .onAppear {
                                HapticManager.shared.impact(.light)
                            }
                    case 3:
                        ConnectionsView(server: server)
                            .onAppear {
                                HapticManager.shared.impact(.light)
                            }
                    case 4:
                        MoreView(server: server)
                            .onAppear {
                                HapticManager.shared.impact(.light)
                            }
                    default:
                        EmptyView()
                    }
                }
                
                // ÊµÆÂä®Ê†áÁ≠æÊ†è
                VStack {
                    Spacer()
                    FloatingTabBar(selectedTab: $selectedTab)
                        .padding(.horizontal, 20)
                        .padding(.bottom, geometry.safeAreaInsets.bottom + 25)
                        .offset(y: isTabBarVisible ? 0 : 120)
                        .animation(.spring(response: 0.6, dampingFraction: 0.8), value: isTabBarVisible)
                }
            }
            .environment(\.floatingTabBarVisible, isTabBarVisible)
        }
        .ignoresSafeArea(.container, edges: .bottom)
        .simultaneousGesture(
            DragGesture()
                .onChanged { value in
                    handleDragGesture(value)
                }
        )
        .navigationTitle(server.name.isEmpty ? "\(server.openWRTUrl ?? server.url):\(server.openWRTPort ?? server.port)" : server.name)
        .navigationBarTitleDisplayMode(.inline)
        .toolbar {
            if server.isQuickLaunch {
                ToolbarItem(placement: .principal) {
                    HStack {
                        Spacer()
                            .frame(width: 25)
                        Text(server.name.isEmpty ? "\(server.openWRTUrl ?? server.url):\(server.openWRTPort ?? server.port)" : server.name)
                            .font(.headline)
                        Image(systemName: "bolt.circle.fill")
                            .foregroundColor(.yellow)
                            .font(.subheadline)
                    }
                }
            } else {
                ToolbarItem(placement: .principal) {
                    Text(server.name.isEmpty ? "\(server.openWRTUrl ?? server.url):\(server.openWRTPort ?? server.port)" : server.name)
                        .font(.headline)
                }
            }
        }
        .toolbarBackground(.visible, for: .navigationBar)
        .toolbarBackground(Color(.systemBackground), for: .navigationBar)
        .onAppear {
            viewModel.serverViewModel.setBingingManager(bindingManager)
            if selectedTab == 0 {
                networkMonitor.startMonitoring(server: server)
            }
        }
        .onDisappear {
            networkMonitor.stopMonitoring()
        }
        .onChange(of: selectedTab) { newTab in
            if newTab == 0 {
                networkMonitor.startMonitoring(server: server)
            } else {
                networkMonitor.stopMonitoring()
            }
        }
        .onChange(of: settingsViewModel.httpPort) { newPort in
            print("üì£ HTTPÁ´ØÂè£Â∑≤Êõ¥Êñ∞: \(newPort)")
            connectivityViewModel.setupWithServer(server, httpPort: newPort, settingsViewModel: settingsViewModel)
            print("üîÑ Â∑≤Êõ¥Êñ∞ConnectionViewModel‰∏≠ÁöÑÁ´ØÂè£: \(newPort)")
        }
    }
    
    @ViewBuilder
    private var fixedTabsView: some View {
        TabView(selection: $selectedTab) {
            // Ê¶ÇËßàÊ†áÁ≠æÈ°µ
            OverviewTab(
                server: server, 
                monitor: networkMonitor, 
                selectedTab: $selectedTab, 
                settingsViewModel: settingsViewModel,
                connectivityViewModel: connectivityViewModel
            )
            .onAppear {
                HapticManager.shared.impact(.light)
                settingsViewModel.fetchConfig(server: server) 
                connectivityViewModel.setupWithServer(server, httpPort: settingsViewModel.httpPort, settingsViewModel: settingsViewModel)
                print("‚öôÔ∏è ServerDetailView - ÂàùÂßãÊúçÂä°Âô®ËÆæÁΩÆ, Á´ØÂè£: \(settingsViewModel.httpPort)")
            }
            .tabItem {
                Label("Ê¶ÇËßà", systemImage: "chart.line.uptrend.xyaxis")
            }
            .tag(0)
            
            // ‰ª£ÁêÜÊ†áÁ≠æÈ°µ
            ProxyView(server: server)
                .onAppear {
                    HapticManager.shared.impact(.light)
                }
                .tabItem {
                    Label("‰ª£ÁêÜ", systemImage: "globe")
                }
                .tag(1)
                
            // ËßÑÂàôÊ†áÁ≠æÈ°µ
            RulesView(server: server)
                .onAppear {
                    HapticManager.shared.impact(.light)
                }
                .tabItem {
                    Label("ËßÑÂàô", systemImage: "ruler")
                }
                .tag(2)
            
            // ËøûÊé•Ê†áÁ≠æÈ°µ
            ConnectionsView(server: server)
                .onAppear {
                    HapticManager.shared.impact(.light)
                }
                .tabItem {
                    Label("ËøûÊé•", systemImage: "link")
                }
                .tag(3)
            
            // Êõ¥Â§öÊ†áÁ≠æÈ°µ
            MoreView(server: server)
                .onAppear {
                    HapticManager.shared.impact(.light)
                }
                .tabItem {
                    Label("Êõ¥Â§ö", systemImage: "ellipsis")
                }
                .tag(4)
        }
        .navigationTitle(server.name.isEmpty ? "\(server.openWRTUrl ?? server.url):\(server.openWRTPort ?? server.port)" : server.name)
        .navigationBarTitleDisplayMode(.inline)
        .toolbar {
            if server.isQuickLaunch {
                ToolbarItem(placement: .principal) {
                    HStack {
                        Spacer()
                            .frame(width: 25)
                        Text(server.name.isEmpty ? "\(server.openWRTUrl ?? server.url):\(server.openWRTPort ?? server.port)" : server.name)
                            .font(.headline)
                        Image(systemName: "bolt.circle.fill")
                            .foregroundColor(.yellow)
                            .font(.subheadline)
                    }
                }
            } else {
                ToolbarItem(placement: .principal) {
                    Text(server.name.isEmpty ? "\(server.openWRTUrl ?? server.url):\(server.openWRTPort ?? server.port)" : server.name)
                        .font(.headline)
                }
            }
        }
        .toolbarBackground(.visible, for: .navigationBar)
        .toolbarBackground(Color(.systemBackground), for: .navigationBar)
        .onAppear {
            viewModel.serverViewModel.setBingingManager(bindingManager)
            if selectedTab == 0 {
                networkMonitor.startMonitoring(server: server)
            }
        }
        .onDisappear {
            networkMonitor.stopMonitoring()
        }
        .onChange(of: selectedTab) { newTab in
            if newTab == 0 {
                networkMonitor.startMonitoring(server: server)
            } else {
                networkMonitor.stopMonitoring()
            }
        }
        .onChange(of: settingsViewModel.httpPort) { newPort in
            print("üì£ HTTPÁ´ØÂè£Â∑≤Êõ¥Êñ∞: \(newPort)")
            connectivityViewModel.setupWithServer(server, httpPort: newPort, settingsViewModel: settingsViewModel)
            print("üîÑ Â∑≤Êõ¥Êñ∞ConnectionViewModel‰∏≠ÁöÑÁ´ØÂè£: \(newPort)")
        }
    }
    
    private func showModeChangeSuccess(mode: String) {
        lastChangedMode = mode
        withAnimation {
            showingModeChangeSuccess = true
        }
        // 2 ÁßíÂêéÈöêËóèÊèêÁ§∫
        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
            withAnimation {
                showingModeChangeSuccess = false
            }
        }
    }
    
    private func handleDragGesture(_ value: DragGesture.Value) {
        let threshold: CGFloat = 20
        let translationY = value.translation.height
        
        withAnimation(.easeInOut(duration: 0.3)) {
            if translationY < -threshold {
                // Dragging up (content scrolling down) - hide tab bar
                isTabBarVisible = false
                // print("üì± ServerDetailView - ÈöêËóèÊµÆÂä®Ê†áÁ≠æÊ†è")
            } else if translationY > threshold {
                // Dragging down (content scrolling up) - show tab bar
                isTabBarVisible = true
                // print("üì± ServerDetailView - ÊòæÁ§∫ÊµÆÂä®Ê†áÁ≠æÊ†è")
            }
        }
    }
}

// Environment key for floating tab bar visibility
struct FloatingTabBarVisibleKey: EnvironmentKey {
    static let defaultValue: Bool = true
}

extension EnvironmentValues {
    var floatingTabBarVisible: Bool {
        get { self[FloatingTabBarVisibleKey.self] }
        set { self[FloatingTabBarVisibleKey.self] = newValue }
    }
}

struct FloatingTabBar: View {
    @Binding var selectedTab: Int
    @State private var animationOffset: CGFloat = 0
    @State private var indicatorOffset: CGFloat = 0
    @State private var containerWidth: CGFloat = 0
    @State private var isAnimating: Bool = false
    @State private var scaleX: CGFloat = 1.0
    @State private var scaleY: CGFloat = 1.0
    @State private var previousSelectedTab: Int = 0
    @State private var skewX: CGFloat = 0.0 // Ê∞¥Âπ≥ÂÄæÊñú
    @State private var cornerRadius: CGFloat = 20.0 // Âä®ÊÄÅÂúÜËßí
    
    @Environment(\.colorScheme) private var colorScheme
    
    private let tabs = [
        (index: 0, title: "Ê¶ÇËßà", icon: "chart.line.uptrend.xyaxis"),
        (index: 1, title: "‰ª£ÁêÜ", icon: "globe"),
        (index: 2, title: "ËßÑÂàô", icon: "ruler"),
        (index: 3, title: "ËøûÊé•", icon: "link"),
        (index: 4, title: "Êõ¥Â§ö", icon: "ellipsis")
    ]
    
    var body: some View {
        GeometryReader { geometry in
            let tabWidth = geometry.size.width / CGFloat(tabs.count)
            
            ZStack {
                // ËÉåÊôØ - ÈÄÇÈÖçÊ∑±Ëâ≤Ê®°Âºè
                RoundedRectangle(cornerRadius: 25)
                    .fill(colorScheme == .dark ? .thickMaterial : .ultraThinMaterial)
                    .background(
                        RoundedRectangle(cornerRadius: 25)
                            .fill(
                                LinearGradient(
                                    gradient: Gradient(colors: colorScheme == .dark ? [
                                        Color.black.opacity(0.9),
                                        Color.gray.opacity(0.3)
                                    ] : [
                                        Color.white.opacity(0.9),
                                        Color.white.opacity(0.7)
                                    ]),
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                )
                            )
                            .blur(radius: 0.5)
                    )
                    .overlay(
                        // Ê∑±Ëâ≤Ê®°Âºè‰∏ãÊ∑ªÂä†ÂæÆÂº±ÁöÑËæπÊ°ÜÂÖâÊôï
                        RoundedRectangle(cornerRadius: 25)
                            .stroke(
                                colorScheme == .dark ? 
                                    Color.white.opacity(0.1) : Color.clear,
                                lineWidth: 0.5
                            )
                    )
                    .shadow(
                        color: colorScheme == .dark ? 
                            Color.black.opacity(0.6) : Color.black.opacity(0.15), 
                        radius: 15, x: 0, y: 8
                    )
                    .shadow(
                        color: colorScheme == .dark ? 
                            Color.black.opacity(0.3) : Color.black.opacity(0.05), 
                        radius: 5, x: 0, y: 2
                    )
                
                // Ê¥ªË∑ÉÊåáÁ§∫Âô®ËÉåÊôØ - ÊñπÂêëÊÄßÊ∞¥Êª¥ÊïàÊûúÔºåÈÄÇÈÖçÊ∑±Ëâ≤Ê®°Âºè
                RoundedRectangle(cornerRadius: cornerRadius)
                    .fill(
                        LinearGradient(
                            gradient: Gradient(colors: colorScheme == .dark ? [
                                Color.accentColor.opacity(0.35),
                                Color.accentColor.opacity(0.25)
                            ] : [
                                Color.accentColor.opacity(0.25),
                                Color.accentColor.opacity(0.15)
                            ]),
                            startPoint: .top,
                            endPoint: .bottom
                        )
                    )
                    .frame(width: tabWidth - 16, height: 50)
                    .scaleEffect(x: scaleX, y: scaleY)
                    .rotation3DEffect(
                        .degrees(skewX),
                        axis: (x: 0, y: 1, z: 0),
                        perspective: 0.5
                    )
                    .offset(x: indicatorOffset)
                
                // Ê†áÁ≠æÊåâÈíÆ
                HStack(spacing: 0) {
                    ForEach(tabs, id: \.index) { tab in
                        Button(action: {
                            // Ëß¶ÂèëÊñπÂêëÊÄßÊ∞¥Êª¥ÂèòÂΩ¢Âä®Áîª
                            triggerDirectionalLiquidAnimation(
                                from: selectedTab,
                                to: tab.index
                            ) {
                                selectedTab = tab.index
                                updateIndicatorPosition(for: tab.index, tabWidth: tabWidth, totalWidth: geometry.size.width)
                            }
                            HapticManager.shared.impact(.medium)
                        }) {
                            VStack(spacing: 4) {
                                // Âõ∫ÂÆöÈ´òÂ∫¶ÁöÑÂõæÊ†áÂÆπÂô®ÔºåÁ°Æ‰øùÂØπÈΩê
                                ZStack {
                                                                    Image(systemName: tab.icon)
                                    .font(.system(size: selectedTab == tab.index ? 18 : 16, weight: .semibold))
                                    .foregroundColor(
                                        selectedTab == tab.index ? 
                                            .accentColor : 
                                            (colorScheme == .dark ? .secondary : .secondary)
                                    )
                                    .scaleEffect(selectedTab == tab.index ? 1.1 : 1.0)
                                    .animation(.spring(response: 0.4, dampingFraction: 0.6), value: selectedTab)
                                }
                                .frame(width: 24, height: 24) // Âõ∫ÂÆöÂõæÊ†áÂÆπÂô®Â∞∫ÂØ∏
                                
                                // Âõ∫ÂÆöÈ´òÂ∫¶ÁöÑÊñáÂ≠óÂÆπÂô®ÔºåÁ°Æ‰øùÂØπÈΩê
                                Text(tab.title)
                                    .font(.system(size: 11, weight: selectedTab == tab.index ? .semibold : .medium))
                                    .foregroundColor(
                                        selectedTab == tab.index ? 
                                            .accentColor : 
                                            (colorScheme == .dark ? Color.secondary : Color.secondary)
                                    )
                                    .scaleEffect(selectedTab == tab.index ? 1.05 : 1.0)
                                    .animation(.spring(response: 0.4, dampingFraction: 0.6), value: selectedTab)
                                    .frame(height: 14) // Âõ∫ÂÆöÊñáÂ≠óÂÆπÂô®È´òÂ∫¶
                                    .multilineTextAlignment(.center)
                            }
                            .frame(maxWidth: .infinity)
                            .padding(.vertical, 12)
                            .contentShape(Rectangle())
                        }
                        .buttonStyle(TabButtonStyle())
                    }
                }
            }
            .onAppear {
                containerWidth = geometry.size.width
                // Á´ãÂç≥ÂàùÂßãÂåñÊåáÁ§∫Âô®‰ΩçÁΩÆÂà∞Á¨¨‰∏Ä‰∏™Ê†áÁ≠æÔºàÁ¥¢Âºï0Ôºâ
                updateIndicatorPosition(for: selectedTab, tabWidth: containerWidth / CGFloat(tabs.count), totalWidth: containerWidth)
            }
            .onChange(of: selectedTab) { newTab in
                updateIndicatorPosition(for: newTab, tabWidth: containerWidth / CGFloat(tabs.count), totalWidth: containerWidth)
            }
            .onChange(of: geometry.size.width) { newWidth in
                containerWidth = newWidth
                updateIndicatorPosition(for: selectedTab, tabWidth: containerWidth / CGFloat(tabs.count), totalWidth: containerWidth)
            }
        }
        .frame(height: 70)
    }
    
    private func updateIndicatorPosition(for index: Int, tabWidth: CGFloat, totalWidth: CGFloat) {
        // ËÆ°ÁÆóÊØè‰∏™Ê†áÁ≠æÁöÑ‰∏≠ÂøÉ‰ΩçÁΩÆÔºåÁõ∏ÂØπ‰∫éÂÆπÂô®Â∑¶ËæπÁºò
        let tabCenterX = (CGFloat(index) + 0.5) * tabWidth
        // ËÆ°ÁÆóÁõ∏ÂØπ‰∫éÂÆπÂô®‰∏≠ÂøÉÁöÑÂÅèÁßª
        let containerCenterX = totalWidth / 2
        // ÊåáÁ§∫Âô®ÂÅèÁßª = Ê†áÁ≠æ‰∏≠ÂøÉ - ÂÆπÂô®‰∏≠ÂøÉ
        // ÂØπ‰∫éÁ¥¢Âºï0ÔºàÁ¨¨‰∏Ä‰∏™Ê†áÁ≠æÔºâÔºåËøô‰ºö‰∫ßÁîüË¥üÂÅèÁßªÔºåÂ∞ÜÊåáÁ§∫Âô®ÊîæÂú®Â∑¶‰æß
        indicatorOffset = tabCenterX - containerCenterX
    }
    
    private func triggerDirectionalLiquidAnimation(from: Int, to: Int, completion: @escaping () -> Void) {
        // Âà§Êñ≠ÁßªÂä®ÊñπÂêë
        let isMovingRight = to > from
        let distance = abs(to - from)
        let intensity = min(CGFloat(distance) * 0.3, 1.0) // Ê†πÊçÆË∑ùÁ¶ªË∞ÉÊï¥Âº∫Â∫¶
        
        // ÂºÄÂßãÂä®ÁîªÁä∂ÊÄÅ
        isAnimating = true
        previousSelectedTab = from
        
        // Á¨¨‰∏ÄÈò∂ÊÆµÔºöËìÑÂäõÂèòÂΩ¢Ôºà0.1ÁßíÔºâ
        withAnimation(.easeIn(duration: 0.1)) {
            // Ê†πÊçÆÊñπÂêëËøõË°åÈ¢ÑÂèòÂΩ¢
            if isMovingRight {
                scaleX = 1.2 + intensity * 0.2  // Âè≥ÁßªÊó∂Âè≥‰æßÊãâ‰º∏Êõ¥Â§ö
                skewX = -3 - intensity * 2       // ÂêëÂè≥ÂÄæÊñú
            } else {
                scaleX = 1.2 + intensity * 0.2  // Â∑¶ÁßªÊó∂Â∑¶‰æßÊãâ‰º∏Êõ¥Â§ö
                skewX = 3 + intensity * 2        // ÂêëÂ∑¶ÂÄæÊñú
            }
            scaleY = 0.85 - intensity * 0.1  // ÂûÇÁõ¥ÂéãÁº©
            cornerRadius = 15 - intensity * 3 // ÂúÜËßíÂèòÂ∞èÔºåÊõ¥ÂÉèÊ∞¥Êª¥
        }
        
        // Á¨¨‰∫åÈò∂ÊÆµÔºöËøêÂä®ÂèòÂΩ¢Ôºà0.6ÁßíÔºâ
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            withAnimation(.spring(response: 0.6, dampingFraction: 0.7)) {
                completion() // ÊâßË°å‰ΩçÁΩÆÊõ¥Êñ∞
                
                // ËøêÂä®‰∏≠ÁöÑÊûÅÁ´ØÂèòÂΩ¢
                if isMovingRight {
                    scaleX = 0.6 - intensity * 0.1  // Ê∞¥Âπ≥ÊûÅÂ∫¶ÂéãÁº©
                    skewX = -8 - intensity * 4       // Êõ¥Âº∫ÁöÑÂè≥ÂÄæÊñú
                } else {
                    scaleX = 0.6 - intensity * 0.1  // Ê∞¥Âπ≥ÊûÅÂ∫¶ÂéãÁº©  
                    skewX = 8 + intensity * 4        // Êõ¥Âº∫ÁöÑÂ∑¶ÂÄæÊñú
                }
                scaleY = 1.3 + intensity * 0.2  // ÂûÇÁõ¥Êãâ‰º∏
                cornerRadius = 25 + intensity * 5 // ËøêÂä®Êó∂ÂèòÂæóÊõ¥ÂúÜÊ∂¶
            }
            
            // Á¨¨‰∏âÈò∂ÊÆµÔºöÂºπÊÄßÊÅ¢Â§çÔºà0.4ÁßíÔºâ
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                withAnimation(.spring(response: 0.4, dampingFraction: 0.8)) {
                    scaleX = 1.0
                    scaleY = 1.0
                    skewX = 0.0
                    cornerRadius = 20.0
                }
                
                // ÁªìÊùüÂä®ÁîªÁä∂ÊÄÅ
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                    isAnimating = false
                }
            }
        }
    }
}

// Ëá™ÂÆö‰πâÊåâÈíÆÊ†∑Âºè
struct TabButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .scaleEffect(configuration.isPressed ? 0.95 : 1.0)
            .opacity(configuration.isPressed ? 0.8 : 1.0)
            .animation(.easeInOut(duration: 0.1), value: configuration.isPressed)
    }
}

#Preview {
    NavigationStack {
        ServerDetailView(server: ClashServer(name: "ÊµãËØïÊúçÂä°Âô®", url: "10.1.1.166", port: "8099", secret: "123456"))
    }
} 
