import Foundation
import OSLog

// UCI ÂìçÂ∫îÁªìÊûÑ‰Ωì
struct UCIResponse: Codable {
    let result: String
    let error: String?
}

private let logger = LogManager.shared


@MainActor
class ConfigSubscriptionViewModel: ObservableObject {
    @Published var subscriptions: [ConfigSubscription] = []
    @Published var isLoading = false
    @Published var showError = false
    @Published var errorMessage: String?
    @Published var templateOptions: [String] = []
    @Published var isUpdating = false
    @Published var isVersionSupported = false
    @Published private(set) var packageName: String
    
    private let server: ClashServer

    let serverViewModel = ServerViewModel()

    let versionService = VersionService()

        
    var currentServer: ClashServer { server }
    
    init(server: ClashServer) {
        self.server = server
        self.packageName = server.luciPackage == .openClash ? "openclash" : "mihomo"
        
        // Â¶ÇÊûúÊòØ mihomoTProxyÔºåÂºÇÊ≠•Ê£ÄÊü•ÊòØÂê¶‰ΩøÁî® nikki
        if server.luciPackage == .mihomoTProxy {
            Task {
                await checkAndUpdatePackageName()
            }
        }
        
        // Â¶ÇÊûúÊòØ OpenClashÔºåÊ£ÄÊü•ÁâàÊú¨
        if server.luciPackage == .openClash {
            Task {
                await checkVersion()
            }
        }
    }
    
    private func checkAndUpdatePackageName() async {
        do {
            let isNikki = try await serverViewModel.checkIsUsingNikki(server)
            await MainActor.run {
                self.packageName = isNikki ? "nikki" : "mihomo"
            }
        } catch {
            logger.error("Ê£ÄÊü• Nikki Áä∂ÊÄÅÂ§±Ë¥•: \(error.localizedDescription)")
            // ‰øùÊåÅÈªòËÆ§ÁöÑ mihomo
        }
    }
    
    private func checkVersion() async {
        do {
            let scheme = server.openWRTUseSSL ? "https" : "http"
            guard let openWRTUrl = server.openWRTUrl else { return }
            let baseURL = "\(scheme)://\(openWRTUrl):\(server.openWRTPort ?? "80")"
            
            let versionInfo = try await versionService.getPluginVersion(
                baseURL: baseURL,
                token: try await getAuthToken(),
                pluginType: .openClash
            )
            
            let currentVersion = versionInfo.version
            let components = currentVersion.split(separator: "-").first?.split(separator: "v").last ?? ""
            isVersionSupported = (String(components)).compare("0.46.073", options: .numeric) != .orderedAscending
            logger.debug("ÂΩìÂâçÁâàÊú¨: \(currentVersion), ÊòØÂê¶ÊîØÊåÅ OpenClash ÂçïÁã¨ËÆ¢ÈòÖÊõ¥Êñ∞: \(isVersionSupported)")
        } catch {
            logger.error("Ëé∑ÂèñÁâàÊú¨‰ø°ÊÅØÂ§±Ë¥•: \(error)")
            isVersionSupported = false
        }
    }
    
    func loadSubscriptions() async {
        isLoading = true
        defer { isLoading = false }
        
        // Âú®Âä†ËΩΩËÆ¢ÈòÖ‰πãÂâçÊ£ÄÊü•Âπ∂Êõ¥Êñ∞ÂåÖÂêç
        if server.luciPackage == .mihomoTProxy {
            await checkAndUpdatePackageName()
        }
        
        do {
            subscriptions = try await fetchSubscriptions()
        } catch {
            errorMessage = error.localizedDescription
            showError = true
        }
    }
    
    private func parseSubscription(_ line: String) -> (key: String, value: String)? {
        let parts = line.split(separator: "=", maxSplits: 1)
        guard parts.count == 2 else { return nil }
        
        let key = String(parts[0])
        let value = String(parts[1]).trimmingCharacters(in: .whitespaces)
        
        if key.contains(".sub_ua") {
            return (key, value.replacingOccurrences(of: "'", with: "").lowercased())
        }
        
        if key.contains(".enabled") || key.contains(".sub_convert") {
            return (key, value.replacingOccurrences(of: "'", with: ""))
        }
        
        if key.contains(".emoji") || key.contains(".udp") || 
           key.contains(".skip_cert_verify") || key.contains(".sort") || 
           key.contains(".node_type") || key.contains(".rule_provider") {
            return (key, value.replacingOccurrences(of: "'", with: ""))
        }
        
        if key.contains(".name") || key.contains(".address") || 
           key.contains(".convert_address") || key.contains(".template") {
            return (key, value.replacingOccurrences(of: "'", with: ""))
        }
        
        return (key, value)
    }
    
    private func fetchSubscriptions() async throws -> [ConfigSubscription] {
        let token = try await getAuthToken()
        
        // ÊûÑÂª∫ËØ∑Ê±Ç
        let scheme = server.openWRTUseSSL ? "https" : "http"
        guard let openWRTUrl = server.openWRTUrl else {
            throw NetworkError.invalidURL
        }
        let baseURL = "\(scheme)://\(openWRTUrl):\(server.openWRTPort ?? "80")"
        
        // Ëé∑ÂèñÁâàÊú¨‰ø°ÊÅØ
//        let versionInfo = try await versionService.getPluginVersion(
//            baseURL: baseURL,
//            token: token,
//            pluginType: server.luciPackage == .openClash ? .openClash : .mihomoTProxy
//        )        
        
        logger.debug("üîó ËÆ¢ÈòÖ - ËØ∑Ê±Ç URL: \(baseURL)/cgi-bin/luci/rpc/sys?auth=\(token)")
        guard let url = URL(string: "\(baseURL)/cgi-bin/luci/rpc/sys?auth=\(token)") else {
            throw NetworkError.invalidURL
        }

        if packageName == "openclash" {
            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")
            request.setValue("sysauth=\(token); sysauth_http=\(token); sysauth_https=\(token)", forHTTPHeaderField: "Cookie")
            
            let command: [String: Any] = [
                "method": "exec",
                "params": ["uci show openclash | grep \"config_subscribe\" | sed 's/openclash\\.//g' | sort"]
            ]
            request.httpBody = try JSONSerialization.data(withJSONObject: command)
            
            let session = URLSession.secure
            let (data, response) = try await session.data(for: request)
            
            guard let httpResponse = response as? HTTPURLResponse,
                httpResponse.statusCode == 200 else {
                throw NetworkError.serverError(500)
            }
            
            let uciResponse: UCIResponse = try JSONDecoder().decode(UCIResponse.self, from: data)
            if let error = uciResponse.error, !error.isEmpty {
                throw NetworkError.serverError(500)
            }
            
            // Ëß£ÊûêÁªìÊûú
            var subscriptions: [ConfigSubscription] = []
            var currentId: Int?
            var currentSub = ConfigSubscription()
            
            let lines = uciResponse.result.components(separatedBy: "\n")
            for line in lines {
                guard let (key, value) = parseSubscription(line) else { continue }
                
                if key.hasPrefix("@config_subscribe[") {
                    if let idStr = key.firstMatch(of: /\[(\d+)\]/)?.1,
                    let id = Int(idStr) {
                        if id != currentId {
                            if currentId != nil {
                                subscriptions.append(currentSub)
                            }
                            currentId = id
                            currentSub = ConfigSubscription(id: id)
                        }
                        
                        if key.contains(".name") {
                            currentSub.name = value
                        } else if key.contains(".address") {
                            currentSub.address = value
                        } else if key.contains(".enabled") {
                            currentSub.enabled = value == "1"
                        } else if key.contains(".sub_ua") {
                            currentSub.subUA = value
                        } else if key.contains(".sub_convert") {
                            currentSub.subConvert = value.trimmingCharacters(in: CharacterSet(charactersIn: "'")) == "1"
                        } else if key.contains(".convert_address") {
                            currentSub.convertAddress = value.trimmingCharacters(in: CharacterSet(charactersIn: "'"))
                        } else if key.contains(".template") {
                            currentSub.template = value.trimmingCharacters(in: CharacterSet(charactersIn: "'"))
                            // Â¶ÇÊûúÊ®°ÊùøÂÄº‰∏∫ "0"ÔºåÂàôË°®Á§∫‰ΩøÁî®Ëá™ÂÆö‰πâÊ®°Êùø
                            if value == "0" {
                                currentSub.template = "custom"
                            }
                        } else if key.contains(".custom_template_url") {
                            currentSub.customTemplateUrl = value.trimmingCharacters(in: CharacterSet(charactersIn: "'"))
                        } else if key.contains(".emoji") {
                            currentSub.emoji = value.trimmingCharacters(in: CharacterSet(charactersIn: "'")) == "true"
                        } else if key.contains(".udp") {
                            currentSub.udp = value.trimmingCharacters(in: CharacterSet(charactersIn: "'")) == "true"
                        } else if key.contains(".skip_cert_verify") {
                            currentSub.skipCertVerify = value.trimmingCharacters(in: CharacterSet(charactersIn: "'")) == "true"
                        } else if key.contains(".sort") {
                            currentSub.sort = value.trimmingCharacters(in: CharacterSet(charactersIn: "'")) == "true"
                        } else if key.contains(".node_type") {
                            currentSub.nodeType = value.trimmingCharacters(in: CharacterSet(charactersIn: "'")) == "true"
                        } else if key.contains(".rule_provider") {
                            currentSub.ruleProvider = value.trimmingCharacters(in: CharacterSet(charactersIn: "'")) == "true"
                        } else if key.contains(".keyword") {
                            let cleanValue = value.trimmingCharacters(in: .whitespaces)
                            if currentSub.keyword == nil {
                                currentSub.keyword = cleanValue
                            } else {
                                currentSub.keyword! += " " + cleanValue
                            }
                            // print("Â§ÑÁêÜÂÖ≥ÈîÆËØç: \(cleanValue)") // Ê∑ªÂä†Ë∞ÉËØïÊó•Âøó
                        } else if key.contains(".ex_keyword") {
                            let cleanValue = value.trimmingCharacters(in: .whitespaces)
                            if currentSub.exKeyword == nil {
                                currentSub.exKeyword = cleanValue
                            } else {
                                currentSub.exKeyword! += " " + cleanValue
                            }
                            // print("Â§ÑÁêÜÊéíÈô§ÂÖ≥ÈîÆËØç: \(cleanValue)") // Ê∑ªÂä†Ë∞ÉËØïÊó•Âøó
                        }
                    }
                }
            } 
            if currentId != nil {
                subscriptions.append(currentSub)
            }

            return subscriptions
        } else {
            // 1. È¶ñÂÖàËé∑ÂèñÊâÄÊúâËÆ¢ÈòÖÈÖçÁΩÆ
            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")
            request.setValue("sysauth=\(token); sysauth_http=\(token); sysauth_https=\(token)", forHTTPHeaderField: "Cookie")
            
            let getAllCommand: [String: Any] = [
                "method": "exec",
                "params": ["uci show \(packageName) | grep \"=subscription\""]
            ]
            request.httpBody = try JSONSerialization.data(withJSONObject: getAllCommand)
            
            let session = URLSession.secure
            let (data, response) = try await session.data(for: request)
            
            guard let httpResponse = response as? HTTPURLResponse,
                  httpResponse.statusCode == 200 else {
                throw NetworkError.serverError(500)
            }
            
            let uciResponse: UCIResponse = try JSONDecoder().decode(UCIResponse.self, from: data)
            if let error = uciResponse.error, !error.isEmpty {
                throw NetworkError.serverError(500)
            }
            
            // 2. Ëß£ÊûêÊâÄÊúâËÆ¢ÈòÖÈÖçÁΩÆ
            var subscriptionPaths: [(path: String, id: String)] = []
            let lines = uciResponse.result.components(separatedBy: "\n")
            for line in lines {
                if line.isEmpty { continue }
                if line.contains("=subscription") {
                    let parts = line.split(separator: "=")
                    if parts.count == 2 {
                        let path = String(parts[0]).trimmingCharacters(in: .whitespaces)
                        let subscriptionId = path.split(separator: ".").last ?? ""
                        subscriptionPaths.append((path: path, id: String(subscriptionId)))
                    }
                }
            }
            
            // 3. Ëé∑ÂèñÊØè‰∏™ËÆ¢ÈòÖÁöÑËØ¶ÁªÜ‰ø°ÊÅØ
            var subscriptions: [ConfigSubscription] = []
            var currentId = 0
            
            for (path, _) in subscriptionPaths {
                let getDetailCommand: [String: Any] = [
                    "method": "exec",
                    "params": ["uci show \(path)"]
                ]
                request.httpBody = try JSONSerialization.data(withJSONObject: getDetailCommand)
                
                let (detailData, detailResponse) = try await session.data(for: request)
                guard let detailHttpResponse = detailResponse as? HTTPURLResponse,
                      detailHttpResponse.statusCode == 200 else {
                    continue
                }
                
                let uciDetailResponse: UCIResponse = try JSONDecoder().decode(UCIResponse.self, from: detailData)
                if let error = uciDetailResponse.error, !error.isEmpty {
                    continue
                }
                
                // 4. Ëß£ÊûêËÆ¢ÈòÖËØ¶ÊÉÖ
                var subscription = ConfigSubscription(id: currentId)
                
                // ‰ªéÁ¨¨‰∏ÄË°åÊèêÂèñ subscriptionId
                let detailLines = uciDetailResponse.result.components(separatedBy: "\u{000a}")
                if let firstLine = detailLines.first,
                   let fullKey = firstLine.split(separator: "=").first {
                    let configId = String(fullKey.split(separator: ".").last ?? "")
                    subscription.subscriptionId = configId
                }
                
                for line in detailLines {
                    if line.isEmpty { continue }
                    let parts = line.split(separator: "=", maxSplits: 1)
                    if parts.count != 2 { continue }
                    
                    let key = String(parts[0].split(separator: ".").last ?? "")
                    let value = String(parts[1]).trimmingCharacters(in: CharacterSet(charactersIn: "'"))
                    
                    switch key {
                    case "name":
                        subscription.name = value
                    case "url":
                        subscription.address = value
                    case "user_agent":
                        subscription.subUA = value.lowercased()
                    case "prefer":
                        subscription.remoteFirst = value == "remote"
                    case "expire":
                        subscription.expire = value
                    case "upload":
                        subscription.upload = value
                    case "download":
                        subscription.download = value
                    case "total":
                        subscription.total = value
                    case "used":
                        subscription.used = value
                    case "avaliable":  // Ê≥®ÊÑèÔºöËøôÈáåÊòØÂéüÂßãÊï∞ÊçÆ‰∏≠ÁöÑÊãºÂÜô
                        subscription.available = value
                    case "update":
                        subscription.lastUpdate = value
                    case "success":
                        subscription.success = value == "1"
                    default:
                        break
                    }
                }
                
                // Âè™ÊúâÂêåÊó∂ÊúâÂêçÁß∞ÂíåÂú∞ÂùÄÁöÑËÆ¢ÈòÖÊâçÊ∑ªÂä†Âà∞ÂàóË°®‰∏≠
                if !subscription.name.isEmpty && !subscription.address.isEmpty {
                    subscription.enabled = true  // mihomo ÁöÑËÆ¢ÈòÖÈªòËÆ§ÂêØÁî®
                    subscriptions.append(subscription)
                    currentId += 1
                }
            }
            
            return subscriptions
        }
    }
    
    internal func getAuthToken() async throws -> String {
        guard let username = server.openWRTUsername,
              let password = server.openWRTPassword else {
            throw NetworkError.unauthorized(message: "Ëé∑Âèñ Token ÈîôËØØ")
        }
        
        let scheme = server.openWRTUseSSL ? "https" : "http"
        guard let openWRTUrl = server.openWRTUrl else {
            throw NetworkError.invalidURL
        }
        let baseURL = "\(scheme)://\(openWRTUrl):\(server.openWRTPort ?? "80")"
        guard let url = URL(string: "\(baseURL)/cgi-bin/luci/rpc/auth") else {
            throw NetworkError.invalidURL
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        let body: [String: Any] = [
            "id": 1,
            "method": "login",
            "params": [username, password]
        ]
        request.httpBody = try JSONSerialization.data(withJSONObject: body)
        
        let (data, response) = try await URLSession.secure.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse,
              httpResponse.statusCode == 200 else {
            throw NetworkError.unauthorized(message: "ÁôªÂΩïÂ§±Ë¥•")
        }
        
        struct AuthResponse: Codable {
            let result: String?
            let error: String?
        }
        
        let authResponse = try JSONDecoder().decode(AuthResponse.self, from: data)
        guard let token = authResponse.result else {
            throw NetworkError.unauthorized(message: "ÁôªÂΩïÂ§±Ë¥•")
        }
        
        return token
    }
    
    func addSubscription(_ subscription: ConfigSubscription) async {
        if packageName == "openclash" {
            do {
                // print("üîÑ ÂºÄÂßãÊ∑ªÂä†ËÆ¢ÈòÖ: \(subscription.name)")
                // print("üìù ËÆ¢ÈòÖ‰ø°ÊÅØ:")
                // printSubscriptionState(subscription)
                
                let token = try await getAuthToken()
                
                // ÊûÑÂª∫ËØ∑Ê±Ç
                let scheme = server.openWRTUseSSL ? "https" : "http"
                guard let openWRTUrl = server.openWRTUrl else {
                    throw NetworkError.invalidURL
                }
                let baseURL = "\(scheme)://\(openWRTUrl):\(server.openWRTPort ?? "80")"
                guard let url = URL(string: "\(baseURL)/cgi-bin/luci/rpc/sys?auth=\(token)") else {
                    throw NetworkError.invalidURL
                }
                
                var request = URLRequest(url: url)
                request.httpMethod = "POST"
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                request.setValue("sysauth=\(token); sysauth_http=\(token); sysauth_https=\(token)", forHTTPHeaderField: "Cookie")
                
                // È¶ñÂÖàËé∑ÂèñÂΩìÂâçËÆ¢ÈòÖÊï∞Èáè
                let countCommand: [String: Any] = [
                    "method": "exec",
                    "params": ["uci show openclash | grep 'config_subscribe.*name' | wc -l"]
                ]
                request.httpBody = try JSONSerialization.data(withJSONObject: countCommand)
                
                let (countData, _) = try await URLSession.secure.data(for: request)
                let countResponse: UCIResponse = try JSONDecoder().decode(UCIResponse.self, from: countData)
                
                guard let countStr = countResponse.result.trimmingCharacters(in: .whitespacesAndNewlines).components(separatedBy: .newlines).first,
                    let count = Int(countStr) else {
                    throw NetworkError.serverError(500)
                }
                
                // ÁîüÊàêÊ∑ªÂä†ÂëΩ‰ª§
                var commands = [
                    "uci add openclash config_subscribe",
                    "uci set openclash.@config_subscribe[\(count)].enabled='\(subscription.enabled ? 1 : 0)'",
                    "uci set openclash.@config_subscribe[\(count)].name='\(subscription.name)'",
                    "uci set openclash.@config_subscribe[\(count)].address='\(subscription.address)'",
                    "uci set openclash.@config_subscribe[\(count)].sub_ua='\(subscription.subUA)'",
                    "uci set openclash.@config_subscribe[\(count)].sub_convert='\(subscription.subConvert ? 1 : 0)'"
                ]
                
                // Ê∑ªÂä†ÂèØÈÄâÂèÇÊï∞
                // ËΩ¨Êç¢ÈÄâÈ°π
                if subscription.subConvert {
                    if let addr = subscription.convertAddress {
                        commands.append("uci set openclash.@config_subscribe[\(count)].convert_address='\(addr)'")
                    }
                    
                    if let template = subscription.template {
                        commands.append("uci set openclash.@config_subscribe[\(count)].template='\(template)'")
                    }

                    // Â∏ÉÂ∞îÂÄºÈÄâÈ°πÔºöÂΩì subConvert ‰∏∫ true Êó∂ÔºåÂßãÁªàËÆæÁΩÆÂÄº
                    let boolOptions = [
                        "emoji": subscription.emoji,
                        "udp": subscription.udp,
                        "skip_cert_verify": subscription.skipCertVerify,
                        "sort": subscription.sort,
                        "node_type": subscription.nodeType,
                        "rule_provider": subscription.ruleProvider
                    ]
                    
                    for (key, value) in boolOptions {
                        // Â¶ÇÊûúÂÄº‰∏∫ nil Êàñ‰∏∫ falseÔºåËÆæÁΩÆ‰∏∫ false
                        // Â¶ÇÊûúÂÄº‰∏∫ trueÔºåËÆæÁΩÆ‰∏∫ true
                        let finalValue = value ?? false
                        commands.append("uci set openclash.@config_subscribe[\(count)].\(key)='\(finalValue ? "true" : "false")'")
                    }
                }
                
                // ÂÖ≥ÈîÆËØçÊØîËæÉ
                if subscription.keyword != nil {
                        
                    let keywords = parseKeywordValues(subscription.keyword) // ‰ΩøÁî®Êñ∞ÁöÑËß£ÊûêÊñπÊ≥ï
                    
                    if !keywords.isEmpty{
                        for keyword in keywords {
                            // print("Ê∑ªÂä†ÂÖ≥ÈîÆËØç: \(keyword)")
                            commands.append("uci add_list openclash.@config_subscribe[\(count)].keyword='\(keyword)'")
                        }
                    }
                }
                
                // ÊéíÈô§ÂÖ≥ÈîÆËØçÊØîËæÉ
                if subscription.exKeyword != nil {
                    let keywords = parseKeywordValues(subscription.exKeyword) // ‰ΩøÁî®Êñ∞ÁöÑËß£ÊûêÊñπÊ≥ï
                    if !keywords.isEmpty{
                        for keyword in keywords {
                            // print("Ê∑ªÂä†ÂÖ≥ÈîÆËØç: \(keyword)")
                            commands.append("uci add_list openclash.@config_subscribe[\(count)].ex_keyword='\(keyword)'")
                        }
                    }
                }
                
                // print("üì§ ÂèëÈÄÅÁöÑÂëΩ‰ª§:")
                // print(commands.joined(separator: " && "))
                
                // ÊâßË°åÊ∑ªÂä†ÂëΩ‰ª§
                let addCommand: [String: Any] = [
                    "method": "exec",
                    "params": [commands.joined(separator: " && ")]
                ]
                request.httpBody = try JSONSerialization.data(withJSONObject: addCommand)
                
                let (data, response) = try await URLSession.secure.data(for: request)
                
                guard let httpResponse = response as? HTTPURLResponse,
                    httpResponse.statusCode == 200 else {
                    throw NetworkError.serverError(500)
                }
                
                let uciResponse: UCIResponse = try JSONDecoder().decode(UCIResponse.self, from: data)
                if let error = uciResponse.error, !error.isEmpty {
                    throw NetworkError.serverError(500)
                }
                
                // print("‚úÖ UCIÂëΩ‰ª§ÊâßË°åÊàêÂäü")
                logger.info("UCIÂëΩ‰ª§ÊâßË°åÊàêÂäü")
                
                // Êèê‰∫§Êõ¥Êîπ
                try await commitChanges(token: token)
                // print("‚úÖ Êõ¥ÊîπÂ∑≤Êèê‰∫§")
                logger.info("Êõ¥ÊîπÂ∑≤Êèê‰∫§")
                
                // ÈáçÊñ∞Âä†ËΩΩËÆ¢ÈòÖÂàóË°®
                await loadSubscriptions()
                // print("‚úÖ ËÆ¢ÈòÖÂàóË°®Â∑≤Âà∑Êñ∞")
                logger.info("ËÆ¢ÈòÖÂàóË°®Â∑≤Âà∑Êñ∞")
                
            } catch {
                // print("‚ùå Ê∑ªÂä†ËÆ¢ÈòÖÂ§±Ë¥•: \(error.localizedDescription)")
                logger.error("Ê∑ªÂä†ËÆ¢ÈòÖÂ§±Ë¥•: \(error.localizedDescription)")
                errorMessage = error.localizedDescription
                showError = true
            }
        } else {
            do {
                // print("üîÑ ÂºÄÂßãÊ∑ªÂä† MihomoTProxy ËÆ¢ÈòÖ: \(subscription.name)")
                // print("üìù ËÆ¢ÈòÖ‰ø°ÊÅØ:")
                // printSubscriptionState(subscription)
                
                let token = try await getAuthToken()
                
                // ÊûÑÂª∫ËØ∑Ê±Ç
                let scheme = server.openWRTUseSSL ? "https" : "http"
                guard let openWRTUrl = server.openWRTUrl else {
                    throw NetworkError.invalidURL
                }
                let baseURL = "\(scheme)://\(openWRTUrl):\(server.openWRTPort ?? "80")"
                guard let url = URL(string: "\(baseURL)/cgi-bin/luci/rpc/sys?auth=\(token)") else {
                    throw NetworkError.invalidURL
                }
                
                var request = URLRequest(url: url)
                request.httpMethod = "POST"
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                request.setValue("sysauth=\(token); sysauth_http=\(token); sysauth_https=\(token)", forHTTPHeaderField: "Cookie")
                
                // ÊûÑÂª∫Ê∑ªÂä†ÂëΩ‰ª§
                let commands = [
                    "uci add \(packageName) subscription",
                    "uci set \(packageName).@subscription[-1].name='\(subscription.name)'",
                    "uci set \(packageName).@subscription[-1].url='\(subscription.address)'",
                    "uci set \(packageName).@subscription[-1].user_agent='\(subscription.subUA)'",
                    "uci set \(packageName).@subscription[-1].prefer='\(subscription.remoteFirst ?? true ? "remote" : "local")'",
                    "uci commit \(packageName)"
                ].joined(separator: " && ")
                
                // print("üì§ ÂèëÈÄÅÁöÑÂëΩ‰ª§:")
                // print(commands)
                
                // ÊâßË°åÊ∑ªÂä†ÂëΩ‰ª§
                let addCommand: [String: Any] = [
                    "method": "exec",
                    "params": [commands]
                ]
                request.httpBody = try JSONSerialization.data(withJSONObject: addCommand)
                
                let (data, response) = try await URLSession.secure.data(for: request)
                
                guard let httpResponse = response as? HTTPURLResponse,
                    httpResponse.statusCode == 200 else {
                    throw NetworkError.serverError(500)
                }
                
                let uciResponse: UCIResponse = try JSONDecoder().decode(UCIResponse.self, from: data)
                if let error = uciResponse.error, !error.isEmpty {
                    throw NetworkError.serverError(500)
                }
                
                // print("‚úÖ UCIÂëΩ‰ª§ÊâßË°åÊàêÂäü")
                logger.info("UCIÂëΩ‰ª§ÊâßË°åÊàêÂäü")
                
                // ÈáçÊñ∞Âä†ËΩΩËÆ¢ÈòÖÂàóË°®
                await loadSubscriptions()
                // print("‚úÖ ËÆ¢ÈòÖÂàóË°®Â∑≤Âà∑Êñ∞")
                logger.info("ËÆ¢ÈòÖÂàóË°®Â∑≤Âà∑Êñ∞")
                
            } catch {
                // print("‚ùå Ê∑ªÂä†ËÆ¢ÈòÖÂ§±Ë¥•: \(error.localizedDescription)")
                logger.error("Ê∑ªÂä†ËÆ¢ÈòÖÂ§±Ë¥•: \(error.localizedDescription)")
                errorMessage = error.localizedDescription
                showError = true
            }
        }
    }

    
    
    // ‰øÆÊîπËß£ÊûêÂÖ≥ÈîÆËØçÁöÑÊñπÊ≥ï
    func parseKeywordValues(_ input: String?) -> [String] {
        guard let input = input else { return [] }
        
        // print("Ëß£ÊûêÂÖ≥ÈîÆËØçËæìÂÖ•: \(input)") // Ê∑ªÂä†Ë∞ÉËØïÊó•Âøó
        
        // ‰ΩøÁî®Ê≠£ÂàôË°®ËææÂºèÂåπÈÖçÂçïÂºïÂè∑‰πãÈó¥ÁöÑÂÜÖÂÆπ
        let pattern = "'([^']+)'"
        guard let regex = try? NSRegularExpression(pattern: pattern) else {
            // print("Ê≠£ÂàôË°®ËææÂºèÂàõÂª∫Â§±Ë¥•") // Ê∑ªÂä†Ë∞ÉËØïÊó•Âøó
            return []
        }
        
        let range = NSRange(location: 0, length: input.utf16.count)
        let matches = regex.matches(in: input, range: range)
        
        let words = matches.compactMap { match -> String? in
            guard let range = Range(match.range(at: 1), in: input) else { return nil }
            let word = String(input[range])
            // print("ÂåπÈÖçÂà∞ÂÖ≥ÈîÆËØç: \(word)") // Ê∑ªÂä†Ë∞ÉËØïÊó•Âøó
            return word
        }
        
        // print("Ëß£ÊûêÁªìÊûú: \(words)") // Ê∑ªÂä†Ë∞ÉËØïÊó•Âøó
        return words
    }
    
    func updateSubscription(_ subscription: ConfigSubscription) async {
        if packageName == "openclash" {
            do {
                // print("üîÑ ÂºÄÂßãÊõ¥Êñ∞ËÆ¢ÈòÖ: \(subscription.name)")
                logger.info("üîÑ ÂºÄÂßãÊõ¥Êñ∞ËÆ¢ÈòÖ: \(subscription.name)")
                // print("üìù ÂΩìÂâçËÆ¢ÈòÖÁä∂ÊÄÅ:")
                // printSubscriptionState(subscription)
                
                let token = try await getAuthToken()
                
                if let oldSub = subscriptions.first(where: { $0.id == subscription.id }) {
                    // print("\nüìù ÂØπÊØîÊóßËÆ¢ÈòÖÁä∂ÊÄÅ:")
                    // printSubscriptionState(oldSub)
                    
                    // print("\nüìù Ê£ÄÊü•Â≠óÊÆµÊõ¥Êîπ...")
                    var commands: [String] = []
                    
                    // Âü∫Êú¨Â≠óÊÆµÊØîËæÉ
                    if oldSub.name != subscription.name {
                        commands.append("uci set openclash.@config_subscribe[\(subscription.id)].name='\(subscription.name)'")
                    }
                    if oldSub.address != subscription.address {
                        commands.append("uci set openclash.@config_subscribe[\(subscription.id)].address='\(subscription.address)'")
                    }
                    if oldSub.subUA != subscription.subUA {
                        commands.append("uci set openclash.@config_subscribe[\(subscription.id)].sub_ua='\(subscription.subUA)'")
                    }
                    if oldSub.enabled != subscription.enabled {
                        commands.append("uci set openclash.@config_subscribe[\(subscription.id)].enabled='\(subscription.enabled ? 1 : 0)'")
                    }
                    if oldSub.subConvert != subscription.subConvert {
                        commands.append("uci set openclash.@config_subscribe[\(subscription.id)].sub_convert='\(subscription.subConvert ? 1 : 0)'")
                    }
                    
                    // ËΩ¨Êç¢ÈÄâÈ°πÊØîËæÉ
                    if subscription.subConvert {
                        if oldSub.convertAddress != subscription.convertAddress {
                            if let addr = subscription.convertAddress {
                                commands.append("uci set openclash.@config_subscribe[\(subscription.id)].convert_address='\(addr)'")
                            }
                        }
                        if oldSub.template != subscription.template {
                            if let template = subscription.template {
                                if template == "custom" {
                                    commands.append("uci set openclash.@config_subscribe[\(subscription.id)].template='0'")
                                    if let customUrl = subscription.customTemplateUrl {
                                        commands.append("uci set openclash.@config_subscribe[\(subscription.id)].custom_template_url='\(customUrl)'")
                                    }
                                } else {
                                    commands.append("uci set openclash.@config_subscribe[\(subscription.id)].template='\(template)'")
                                }
                            }
                        } else if oldSub.customTemplateUrl != subscription.customTemplateUrl {
                            if let customUrl = subscription.customTemplateUrl {
                                commands.append("uci set openclash.@config_subscribe[\(subscription.id)].custom_template_url='\(customUrl)'")
                            }
                        }

                        // Â∏ÉÂ∞îÂÄºÈÄâÈ°πÔºöÂΩì subConvert ‰∏∫ true Êó∂ÔºåÂßãÁªàËÆæÁΩÆÂÄº
                        let boolOptions = [
                            "emoji": subscription.emoji,
                            "udp": subscription.udp,
                            "skip_cert_verify": subscription.skipCertVerify,
                            "sort": subscription.sort,
                            "node_type": subscription.nodeType,
                            "rule_provider": subscription.ruleProvider
                        ]
                        
                        for (key, value) in boolOptions {
                            // Â¶ÇÊûúÂÄº‰∏∫ nil Êàñ‰∏∫ falseÔºåËÆæÁΩÆ‰∏∫ false
                            // Â¶ÇÊûúÂÄº‰∏∫ trueÔºåËÆæÁΩÆ‰∏∫ true
                            let finalValue = value ?? false
                            commands.append("uci set openclash.@config_subscribe[\(subscription.id)].\(key)='\(finalValue ? "true" : "false")'")
                        }
                    }
                    
                    // ÂÖ≥ÈîÆËØçÊØîËæÉ
                    if oldSub.keyword != subscription.keyword {
                            
                        let keywords = parseKeywordValues(subscription.keyword) // ‰ΩøÁî®Êñ∞ÁöÑËß£ÊûêÊñπÊ≥ï
                        
                        if !keywords.isEmpty{
                        // Âè™ÊúâÂΩìÊóßÂÄºÂ≠òÂú®Êó∂ÊâçÂèëÈÄÅ delete ÂëΩ‰ª§
                            if oldSub.keyword != nil {
                                commands.append("uci delete openclash.@config_subscribe[\(subscription.id)].keyword")
                            }
                            for keyword in keywords {
                                // print("Ê∑ªÂä†ÂÖ≥ÈîÆËØç: \(keyword)")
                                commands.append("uci add_list openclash.@config_subscribe[\(subscription.id)].keyword='\(keyword)'")
                            }
                        }else {
                                commands.append("uci delete openclash.@config_subscribe[\(subscription.id)].keyword")
                        }
                    }
                    
                    // ÊéíÈô§ÂÖ≥ÈîÆËØçÊØîËæÉ
                    if oldSub.exKeyword != subscription.exKeyword {
                        let keywords = parseKeywordValues(subscription.exKeyword) // ‰ΩøÁî®Êñ∞ÁöÑËß£ÊûêÊñπÊ≥ï
                        if !keywords.isEmpty{
                        // Âè™ÊúâÂΩìÊóßÂÄºÂ≠òÂú®Êó∂ÊâçÂèëÈÄÅ delete ÂëΩ‰ª§
                            if oldSub.exKeyword != nil {
                                commands.append("uci delete openclash.@config_subscribe[\(subscription.id)].ex_keyword")
                            }
                            for keyword in keywords {
                                // print("Ê∑ªÂä†ÂÖ≥ÈîÆËØç: \(keyword)")
                                commands.append("uci add_list openclash.@config_subscribe[\(subscription.id)].ex_keyword='\(keyword)'")
                            }
                        }else{
                        commands.append("uci delete openclash.@config_subscribe[\(subscription.id)].ex_keyword")
                        }
                    }
                    
                    // Ëá™ÂÆö‰πâÂèÇÊï∞ÊØîËæÉ
    //                if oldSub.customParams != subscription.customParams {
    //                    if let params = subscription.customParams {
    //                        if oldSub.customParams != nil {
    //                            commands.append("uci delete openclash.@config_subscribe[\(subscription.id)].custom_params")
    //                        }
    //                        for param in params {
    //                            commands.append("uci add_list openclash.@config_subscribe[\(subscription.id)].custom_params='\(param)'")
    //                        }
    //                    }
    //                }
                    
                    if commands.isEmpty {
                        // print("‚ÑπÔ∏è Ê≤°ÊúâÂ≠óÊÆµË¢´Êõ¥ÊîπÔºåË∑≥ËøáÊõ¥Êñ∞")
                        return
                    }
                    
                    // ÊûÑÂª∫ËØ∑Ê±Ç
                    let scheme = server.openWRTUseSSL ? "https" : "http"
                    guard let openWRTUrl = server.openWRTUrl else {
                        throw NetworkError.invalidURL
                    }
                    let baseURL = "\(scheme)://\(openWRTUrl):\(server.openWRTPort ?? "80")"
                    guard let url = URL(string: "\(baseURL)/cgi-bin/luci/rpc/sys?auth=\(token)") else {
                        throw NetworkError.invalidURL
                    }
                    
                    var request = URLRequest(url: url)
                    request.httpMethod = "POST"
                    request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                    request.setValue("sysauth=\(token); sysauth_http=\(token); sysauth_https=\(token)", forHTTPHeaderField: "Cookie")
                    
                    let command: [String: Any] = [
                        "method": "exec",
                        "params": [commands.joined(separator: " && ")]
                    ]
                    request.httpBody = try JSONSerialization.data(withJSONObject: command)
                    
                    let session = URLSession.secure
                    let (data, response) = try await session.data(for: request)
                    
                    guard let httpResponse = response as? HTTPURLResponse,
                        httpResponse.statusCode == 200 else {
                        // print("‚ùå ÊúçÂä°Âô®ËøîÂõûÈîôËØØÁä∂ÊÄÅÁ†Å: \((response as? HTTPURLResponse)?.statusCode ?? 0)")
                        throw NetworkError.serverError(500)
                    }
                    
                    let uciResponse: UCIResponse = try JSONDecoder().decode(UCIResponse.self, from: data)
                    if let error = uciResponse.error, !error.isEmpty {
                        // print("UCIÂëΩ‰ª§ÊâßË°åÂ§±Ë¥•: \(error)")
                        throw NetworkError.serverError(500)
                    }

                    // print("üì§ ÂèëÈÄÅÁöÑÂëΩ‰ª§:")
                    print(commands.joined(separator: " && "))
                    
                    // print("‚úÖ UCIÂëΩ‰ª§ÊâßË°åÊàêÂäü")
                    
                    // Êèê‰∫§Êõ¥Êîπ
                    try await commitChanges(token: token)
                    // print("‚úÖ Êõ¥ÊîπÂ∑≤Êèê‰∫§")
                    
                    // ÈáçÊñ∞Âä†ËΩΩËÆ¢ÈòÖÂàóË°®
                    await loadSubscriptions()
                    // print("‚úÖ ËÆ¢ÈòÖÂàóË°®Â∑≤Âà∑Êñ∞")
                    logger.info("ËÆ¢ÈòÖÂàóË°®Â∑≤Âà∑Êñ∞")
                }
                
            } catch {
                // print("‚ùå Êõ¥Êñ∞ËÆ¢ÈòÖÂ§±Ë¥•: \(error.localizedDescription)")
                errorMessage = error.localizedDescription
                showError = true
            }
        } else {
            do {
                // print("üîÑ ÂºÄÂßãÊõ¥Êñ∞ MihomoTProxy ËÆ¢ÈòÖ: \(subscription.name)")
                logger.info("üîÑ ÂºÄÂßãÊõ¥Êñ∞ Nikki ËÆ¢ÈòÖ: \(subscription.name)")
                
                let token = try await getAuthToken()
                
                // ÊûÑÂª∫ËØ∑Ê±Ç
                let scheme = server.openWRTUseSSL ? "https" : "http"
                guard let openWRTUrl = server.openWRTUrl else {
                    throw NetworkError.invalidURL
                }
                let baseURL = "\(scheme)://\(openWRTUrl):\(server.openWRTPort ?? "80")"
                guard let url = URL(string: "\(baseURL)/cgi-bin/luci/rpc/sys?auth=\(token)") else {
                    throw NetworkError.invalidURL
                }
                
                var request = URLRequest(url: url)
                request.httpMethod = "POST"
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                request.setValue("sysauth=\(token); sysauth_http=\(token); sysauth_https=\(token)", forHTTPHeaderField: "Cookie")
                
                // ÊûÑÂª∫Êõ¥Êñ∞ÂëΩ‰ª§
                let commands = [
                    "uci set \(packageName).@subscription[\(subscription.id)].name='\(subscription.name)'",
                    "uci set \(packageName).@subscription[\(subscription.id)].url='\(subscription.address)'",
                    "uci set \(packageName).@subscription[\(subscription.id)].user_agent='\(subscription.subUA)'",
                    "uci set \(packageName).@subscription[\(subscription.id)].prefer='\(subscription.remoteFirst ?? true ? "remote" : "local")'",
                    "uci commit \(packageName)"
                ].joined(separator: " && ")
                
                // print("üì§ ÂèëÈÄÅÁöÑÂëΩ‰ª§:")
                // print(commands)
                
                // ÊâßË°åÊõ¥Êñ∞ÂëΩ‰ª§
                let updateCommand: [String: Any] = [
                    "method": "exec",
                    "params": [commands]
                ]
                request.httpBody = try JSONSerialization.data(withJSONObject: updateCommand)
                
                let (data, response) = try await URLSession.secure.data(for: request)
                
                guard let httpResponse = response as? HTTPURLResponse,
                    httpResponse.statusCode == 200 else {
                    throw NetworkError.serverError(500)
                }
                
                let uciResponse: UCIResponse = try JSONDecoder().decode(UCIResponse.self, from: data)
                if let error = uciResponse.error, !error.isEmpty {
                    throw NetworkError.serverError(500)
                }
                
                // print("‚úÖ UCIÂëΩ‰ª§ÊâßË°åÊàêÂäü")
                logger.info("UCIÂëΩ‰ª§ÊâßË°åÊàêÂäü")
                
                // ÈáçÊñ∞Âä†ËΩΩËÆ¢ÈòÖÂàóË°®
                await loadSubscriptions()
                // print("‚úÖ ËÆ¢ÈòÖÂàóË°®Â∑≤Âà∑Êñ∞")
                logger.info("ËÆ¢ÈòÖÂàóË°®Â∑≤Âà∑Êñ∞")
                
            } catch {
                // print("‚ùå Êõ¥Êñ∞ËÆ¢ÈòÖÂ§±Ë¥•: \(error.localizedDescription)")
                logger.error("Êõ¥Êñ∞ËÆ¢ÈòÖÂ§±Ë¥•: \(error.localizedDescription)")
                errorMessage = error.localizedDescription
                showError = true
            }
        }
    }
    
    func toggleSubscription(_ subscription: ConfigSubscription, enabled: Bool) async {
        // print("üîÑ ÂàáÊç¢ËÆ¢ÈòÖÁä∂ÊÄÅ: \(subscription.name) -> \(enabled ? "ÂêØÁî®" : "Á¶ÅÁî®")")
        do {
            let token = try await getAuthToken()
            
            // ÊûÑÂª∫ËØ∑Ê±Ç
            let scheme = server.openWRTUseSSL ? "https" : "http"
            guard let openWRTUrl = server.openWRTUrl else {
                throw NetworkError.invalidURL
            }
            let baseURL = "\(scheme)://\(openWRTUrl):\(server.openWRTPort ?? "80")"
            guard let url = URL(string: "\(baseURL)/cgi-bin/luci/rpc/sys?auth=\(token)") else {
                throw NetworkError.invalidURL
            }
            
            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")
            request.setValue("sysauth=\(token); sysauth_http=\(token); sysauth_https=\(token)", forHTTPHeaderField: "Cookie")
            
            let command: [String: Any] = [
                "method": "exec",
                "params": ["uci set openclash.@config_subscribe[\(subscription.id)].enabled='\(enabled ? 1 : 0)' && uci commit openclash"]
            ]
            request.httpBody = try JSONSerialization.data(withJSONObject: command)
            
            // print("üì§ ÂèëÈÄÅÂàáÊç¢ÂëΩ‰ª§...")
            let session = URLSession.secure
            let (data, response) = try await session.data(for: request)
            
            guard let httpResponse = response as? HTTPURLResponse,
                  httpResponse.statusCode == 200 else {
                // print("‚ùå ÊúçÂä°Âô®ËøîÂõûÈîôËØØÁä∂ÊÄÅÁ†Å: \((response as? HTTPURLResponse)?.statusCode ?? 0)")
                throw NetworkError.serverError(500)
            }
            
            let uciResponse: UCIResponse = try JSONDecoder().decode(UCIResponse.self, from: data)
            if let error = uciResponse.error, !error.isEmpty {
                // print("‚ùå UCIÂëΩ‰ª§ÊâßË°åÂ§±Ë¥•: \(error)")
                throw NetworkError.serverError(500)
            }
            
            // print("‚úÖ UCIÂëΩ‰ª§ÊâßË°åÊàêÂäü")
            
            // Êèê‰∫§Êõ¥Êîπ
            try await commitChanges(token: token)
            // print("‚úÖ Êõ¥ÊîπÂ∑≤Êèê‰∫§")
            
            // ÈáçÊñ∞Âä†ËΩΩËÆ¢ÈòÖÂàóË°®
            await loadSubscriptions()
            // print("‚úÖ ËÆ¢ÈòÖÂàóË°®Â∑≤Âà∑Êñ∞")
            
        } catch {
            // print("‚ùå ÂàáÊç¢ËÆ¢ÈòÖÁä∂ÊÄÅÂ§±Ë¥•: \(error.localizedDescription)")
            errorMessage = error.localizedDescription
            showError = true
        }
    }
    
    private func commitChanges(token: String) async throws {
        let scheme = server.openWRTUseSSL ? "https" : "http"
        guard let openWRTUrl = server.openWRTUrl else {
                    throw NetworkError.invalidURL
                }
        let baseURL = "\(scheme)://\(openWRTUrl):\(server.openWRTPort ?? "80")"
        guard let url = URL(string: "\(baseURL)/cgi-bin/luci/rpc/sys?auth=\(token)") else {
            throw NetworkError.invalidURL
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("sysauth=\(token); sysauth_http=\(token); sysauth_https=\(token)", forHTTPHeaderField: "Cookie")
        
        let command: [String: Any] = [
            "method": "exec",
            "params": ["uci commit openclash"]
        ]
        request.httpBody = try JSONSerialization.data(withJSONObject: command)
        
        let session = URLSession.secure
        let (data, response) = try await session.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse,
              httpResponse.statusCode == 200 else {
            throw NetworkError.serverError(500)
        }
        
        let uciResponse: UCIResponse = try JSONDecoder().decode(UCIResponse.self, from: data)
        if let error = uciResponse.error, !error.isEmpty {
            throw NetworkError.serverError(500)
        }
    }
    
    // ‰øÆÊîπÊ†ºÂºèÂåñÂÖ≥ÈîÆËØçÁöÑÊñπÊ≥ï
    func formatQuotedValues(_ values: [String]) -> String? {
        let filtered = values.filter { !$0.isEmpty }
        // ÊØè‰∏™ÂÖ≥ÈîÆËØçÈúÄË¶Å‰∏ÄÂ±ÇÂçïÂºïÂè∑
        let formatted = filtered.isEmpty ? nil : filtered.map { 
            let trimmed = $0.trimmingCharacters(in: .whitespaces)
            return "'\(trimmed)'"
        }.joined(separator: " ")
        // print("Ê†ºÂºèÂåñÂÖ≥ÈîÆËØç: \(values) -> \(formatted ?? "nil")") // Ê∑ªÂä†Ë∞ÉËØïÊó•Âøó
        return formatted
    }
    
    // ‰øÆÊîπËß£ÊûêÂÖ≥ÈîÆËØçÁöÑÊñπÊ≥ï
    func parseQuotedValues(_ input: String?) -> [String] {
        guard let input = input else { return [] }
        
        // print("Ëß£ÊûêÂÖ≥ÈîÆËØçËæìÂÖ•: \(input)") // Ê∑ªÂä†Ë∞ÉËØïÊó•Âøó
        
        // ‰ΩøÁî®Ê≠£ÂàôË°®ËææÂºèÂåπÈÖçÂçïÂºïÂè∑‰πãÈó¥ÁöÑÂÜÖÂÆπ
        let pattern = "'([^']+)'"
        guard let regex = try? NSRegularExpression(pattern: pattern) else {
            // print("Ê≠£ÂàôË°®ËææÂºèÂàõÂª∫Â§±Ë¥•") // Ê∑ªÂä†Ë∞ÉËØïÊó•Âøó
            return []
        }
        
        let range = NSRange(location: 0, length: input.utf16.count)
        let matches = regex.matches(in: input, range: range)
        
        let words = matches.compactMap { match -> String? in
            guard let range = Range(match.range(at: 1), in: input) else { return nil }
            let word = String(input[range])
            // print("ÂåπÈÖçÂà∞ÂÖ≥ÈîÆËØç: \(word)") // Ê∑ªÂä†Ë∞ÉËØïÊó•Âøó
            return word
        }
        
        // print("Ëß£ÊûêÁªìÊûú: \(words)") // Ê∑ªÂä†Ë∞ÉËØïÊó•Âøó
        return words
    }
    
    // ËæÖÂä©ÊñπÊ≥ïÔºöÊâìÂç∞ËÆ¢ÈòÖÁä∂ÊÄÅ
    private func printSubscriptionState(_ subscription: ConfigSubscription) {
        // print("- ÂêçÁß∞: \(subscription.name.replacingOccurrences(of: "'", with: ""))")
        // print("- Âú∞ÂùÄ: \(subscription.address.replacingOccurrences(of: "'", with: ""))")
        // print("- ÂêØÁî®Áä∂ÊÄÅ: \(subscription.enabled)")
        // print("- User-Agent: \(subscription.subUA)")
        // print("- ËÆ¢ÈòÖËΩ¨Êç¢: \(subscription.subConvert)")
        if subscription.subConvert {
//             print("  - ËΩ¨Êç¢Âú∞ÂùÄ: \(subscription.convertAddress ?? "Êó†")")
//             print("  - ËΩ¨Êç¢Ê®°Êùø: \(subscription.template ?? "Êó†")")
//             print("  - Emoji: \(subscription.emoji ?? false)")
//             print("  - UDP: \(subscription.udp ?? false)")
//             print("  - Ë∑≥ËøáËØÅ‰π¶È™åËØÅ: \(subscription.skipCertVerify ?? false)")
//             print("  - ÊéíÂ∫è: \(subscription.sort ?? false)")
//             print("  - ËäÇÁÇπÁ±ªÂûã: \(subscription.nodeType ?? false)")
//             print("  - ËßÑÂàôÈõÜ: \(subscription.ruleProvider ?? false)")
// //            print("  - Ëá™ÂÆö‰πâÂèÇÊï∞: \(subscription.customParams ?? [])")
        }
        // print("- ÂåÖÂê´ÂÖ≥ÈîÆËØç: \(subscription.keyword ?? "Êó†")")
        // print("- ÊéíÈô§ÂÖ≥ÈîÆËØç: \(subscription.exKeyword ?? "Êó†")")
    }
    
    func loadTemplateOptions() async {
        do {
            let token = try await getAuthToken()
            
            let scheme = server.openWRTUseSSL ? "https" : "http"
            guard let openWRTUrl = server.openWRTUrl else {
                throw NetworkError.invalidURL
            }
            let baseURL = "\(scheme)://\(openWRTUrl):\(server.openWRTPort ?? "80")"
            guard let url = URL(string: "\(baseURL)/cgi-bin/luci/rpc/sys?auth=\(token)") else {
                throw NetworkError.invalidURL
            }
            
            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")
            request.setValue("sysauth=\(token); sysauth_http=\(token); sysauth_https=\(token)", forHTTPHeaderField: "Cookie")
            
            let command: [String: Any] = [
                "method": "exec",
                "params": ["cat /usr/share/openclash/res/sub_ini.list | cut -d',' -f1"]
            ]
            request.httpBody = try JSONSerialization.data(withJSONObject: command)
            
            let (data, response) = try await URLSession.secure.data(for: request)
            
            guard let httpResponse = response as? HTTPURLResponse,
                  httpResponse.statusCode == 200 else {
                throw NetworkError.serverError(500)
            }
            
            struct TemplateResponse: Codable {
                let result: String
                let error: String?
            }

            let templateResponse = try JSONDecoder().decode(TemplateResponse.self, from: data)
            if let error = templateResponse.error, !error.isEmpty {
                throw NetworkError.serverError(500) 
            }

            templateOptions = templateResponse.result
                .components(separatedBy: "\n")
                .filter { !$0.isEmpty }
                .map { $0.trimmingCharacters(in: CharacterSet(charactersIn: "'")) }

        } catch {
            // print("‚ùå Âä†ËΩΩÊ®°ÊùøÈÄâÈ°πÂ§±Ë¥•: \(error.localizedDescription)")
            errorMessage = error.localizedDescription
            showError = true
        }
    }
    
    func deleteSubscription(_ subscription: ConfigSubscription) async {
        if packageName == "openclash" {
            do {
                // print("üóëÔ∏è ÂºÄÂßãÂà†Èô§ËÆ¢ÈòÖ: \(subscription.name)")
                
                let token = try await getAuthToken()
                
                // ÊûÑÂª∫ËØ∑Ê±Ç
                let scheme = server.openWRTUseSSL ? "https" : "http"
                guard let openWRTUrl = server.openWRTUrl else {
                    throw NetworkError.invalidURL
                }
                
                let baseURL = "\(scheme)://\(openWRTUrl):\(server.openWRTPort ?? "80")"
                guard let url = URL(string: "\(baseURL)/cgi-bin/luci/rpc/sys?auth=\(token)") else {
                    throw NetworkError.invalidURL
                }
                
                var request = URLRequest(url: url)
                request.httpMethod = "POST"
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                request.setValue("sysauth=\(token); sysauth_http=\(token); sysauth_https=\(token)", forHTTPHeaderField: "Cookie")
                
                // Âà†Èô§ÂëΩ‰ª§
                let commands = [
                    "uci delete openclash.@config_subscribe[\(subscription.id)]",
                    "uci commit openclash"
                ]
                
                let command: [String: Any] = [
                    "method": "exec",
                    "params": [commands.joined(separator: " && ")]
                ]
                request.httpBody = try JSONSerialization.data(withJSONObject: command)
                
                let (data, response) = try await URLSession.secure.data(for: request)
                
                guard let httpResponse = response as? HTTPURLResponse,
                    httpResponse.statusCode == 200 else {
                    throw NetworkError.serverError(500)
                }
                
                let uciResponse: UCIResponse = try JSONDecoder().decode(UCIResponse.self, from: data)
                if let error = uciResponse.error, !error.isEmpty {
                    throw NetworkError.serverError(500)
                }
                
                // print("‚úÖ Âà†Èô§ÊàêÂäü")
                logger.info("Âà†Èô§ÊàêÂäü")
                
                // ÈáçÊñ∞Âä†ËΩΩËÆ¢ÈòÖÂàóË°®
                await loadSubscriptions()
                
            } catch {
                // print("‚ùå Âà†Èô§ËÆ¢ÈòÖÂ§±Ë¥•: \(error.localizedDescription)")
                logger.error("Âà†Èô§ËÆ¢ÈòÖÂ§±Ë¥•: \(error.localizedDescription)")
                errorMessage = error.localizedDescription
                showError = true
            }
        } else {
            do {
                // print("üóëÔ∏è ÂºÄÂßãÂà†Èô§ MihomoTProxy ËÆ¢ÈòÖ: \(subscription.name)")
                
                let token = try await getAuthToken()
                
                // ÊûÑÂª∫ËØ∑Ê±Ç
                let scheme = server.openWRTUseSSL ? "https" : "http"
                guard let openWRTUrl = server.openWRTUrl else {
                    throw NetworkError.invalidURL
                }
                
                let baseURL = "\(scheme)://\(openWRTUrl):\(server.openWRTPort ?? "80")"
                guard let url = URL(string: "\(baseURL)/cgi-bin/luci/rpc/sys?auth=\(token)") else {
                    throw NetworkError.invalidURL
                }
                
                var request = URLRequest(url: url)
                request.httpMethod = "POST"
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                request.setValue("sysauth=\(token); sysauth_http=\(token); sysauth_https=\(token)", forHTTPHeaderField: "Cookie")
                
                // Âà†Èô§ÂëΩ‰ª§
                let commands = [
                    "uci delete \(packageName).\(subscription.subscriptionId ?? "")",
                    "uci commit \(packageName)"
                ]
                
                let command: [String: Any] = [
                    "method": "exec",
                    "params": [commands.joined(separator: " && ")]
                ]
                request.httpBody = try JSONSerialization.data(withJSONObject: command)
                
                let (data, response) = try await URLSession.secure.data(for: request)
                
                guard let httpResponse = response as? HTTPURLResponse,
                    httpResponse.statusCode == 200 else {
                    throw NetworkError.serverError(500)
                }
                
                let uciResponse: UCIResponse = try JSONDecoder().decode(UCIResponse.self, from: data)
                if let error = uciResponse.error, !error.isEmpty {
                    throw NetworkError.serverError(500)
                }
                
                // print("‚úÖ Âà†Èô§ÊàêÂäü")
                logger.info("Âà†Èô§ÊàêÂäü")
                
                // ÈáçÊñ∞Âä†ËΩΩËÆ¢ÈòÖÂàóË°®
                await loadSubscriptions()
                
            } catch {
                // print("‚ùå Âà†Èô§ËÆ¢ÈòÖÂ§±Ë¥•: \(error.localizedDescription)")
                logger.error("Âà†Èô§ËÆ¢ÈòÖÂ§±Ë¥•: \(error.localizedDescription)")
                errorMessage = error.localizedDescription
                showError = true
            }
        }
    }
    
    
    // Ê∑ªÂä†Êõ¥Êñ∞ÊâÄÊúâËÆ¢ÈòÖÁöÑÊñπÊ≥ï
    func updateAllSubscriptions() async throws {
        logger.info("ÂºÄÂßãÊõ¥Êñ∞ÂÖ®ÈÉ®ËÆ¢ÈòÖ")
        isUpdating = true
        defer { isUpdating = false }
        
        let token = try await getAuthToken()
        
        let scheme = server.openWRTUseSSL ? "https" : "http"
        guard let openWRTUrl = server.openWRTUrl else {
            throw NetworkError.invalidURL
        }
        let baseURL = "\(scheme)://\(openWRTUrl):\(server.openWRTPort ?? "80")"
        guard let url = URL(string: "\(baseURL)/cgi-bin/luci/rpc/sys?auth=\(token)") else {
            throw NetworkError.invalidURL
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("sysauth=\(token); sysauth_http=\(token); sysauth_https=\(token)", forHTTPHeaderField: "Cookie")
        
        let command: [String: Any] = [
            "method": "exec",
            "params": ["rm -f /tmp/Proxy_Group && uci set openclash.config.enable=1 && uci commit openclash && rm -f /etc/openclash/backup/*.yaml && rm -f /etc/openclash/backup/*.yml && /usr/share/openclash/openclash.sh"]
        ]
        request.httpBody = try JSONSerialization.data(withJSONObject: command)
        
        let (data, response) = try await URLSession.secure.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse,
              httpResponse.statusCode == 200 else {
            throw NetworkError.serverError(500)
        }
        struct UCIResponse: Codable {
            let result: String
            let error: String?
        }
        
        let uciResponse = try JSONDecoder().decode(UCIResponse.self, from: data)
        if let error = uciResponse.error, !error.isEmpty {
            throw NetworkError.serverError(500)
        }
        
        // Á≠âÂæÖ3Áßí
        try await Task.sleep(nanoseconds: 1_000_000_000)
        
        // ÈáçÊñ∞Âä†ËΩΩËÆ¢ÈòÖÂàóË°®
        await loadSubscriptions()
    }
    
    // Ëé∑ÂèñÂçï‰∏™ËÆ¢ÈòÖÁöÑËØ¶ÁªÜ‰ø°ÊÅØ
    private func fetchSubscriptionDetail(_ subscriptionId: String) async throws -> ConfigSubscription? {
        let token = try await getAuthToken()
        
        let scheme = server.openWRTUseSSL ? "https" : "http"
        guard let openWRTUrl = server.openWRTUrl else {
            throw NetworkError.invalidURL
        }
        let baseURL = "\(scheme)://\(openWRTUrl):\(server.openWRTPort ?? "80")"
        guard let url = URL(string: "\(baseURL)/cgi-bin/luci/rpc/sys?auth=\(token)") else {
            throw NetworkError.invalidURL
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("sysauth=\(token); sysauth_http=\(token); sysauth_https=\(token)", forHTTPHeaderField: "Cookie")
        
        // Ëé∑ÂèñËÆ¢ÈòÖËØ¶ÊÉÖ
        let getDetailCommand: [String: Any] = [
            "method": "exec",
            "params": ["uci show \(packageName).\(subscriptionId)"]
        ]
        request.httpBody = try JSONSerialization.data(withJSONObject: getDetailCommand)
        
        let (detailData, detailResponse) = try await URLSession.secure.data(for: request)
        guard let detailHttpResponse = detailResponse as? HTTPURLResponse,
              detailHttpResponse.statusCode == 200 else {
            throw NetworkError.serverError(500)
        }
        
        let uciDetailResponse: UCIResponse = try JSONDecoder().decode(UCIResponse.self, from: detailData)
        if let error = uciDetailResponse.error, !error.isEmpty {
            throw NetworkError.serverError(500)
        }
        
        // Ëß£ÊûêËÆ¢ÈòÖËØ¶ÊÉÖ
        var subscription = ConfigSubscription()
        subscription.subscriptionId = subscriptionId
        
        let detailLines = uciDetailResponse.result.components(separatedBy: "\u{000a}")
        for line in detailLines {
            if line.isEmpty { continue }
            let parts = line.split(separator: "=", maxSplits: 1)
            if parts.count != 2 { continue }
            
            let key = String(parts[0].split(separator: ".").last ?? "")
            let value = String(parts[1]).trimmingCharacters(in: CharacterSet(charactersIn: "'"))
            
            switch key {
            case "name":
                subscription.name = value
            case "url":
                subscription.address = value
            case "user_agent":
                subscription.subUA = value.lowercased()
            case "prefer":
                subscription.remoteFirst = value == "remote"
            case "expire":
                subscription.expire = value
            case "upload":
                subscription.upload = value
            case "download":
                subscription.download = value
            case "total":
                subscription.total = value
            case "used":
                subscription.used = value
            case "avaliable":  // Ê≥®ÊÑèÔºöËøôÈáåÊòØÂéüÂßãÊï∞ÊçÆ‰∏≠ÁöÑÊãºÂÜô
                subscription.available = value
            case "update":
                subscription.lastUpdate = value
            case "success":
                subscription.success = value == "1"
            default:
                break
            }
        }
        
        // Âè™ÊúâÂêåÊó∂ÊúâÂêçÁß∞ÂíåÂú∞ÂùÄÁöÑËÆ¢ÈòÖÊâçËøîÂõû
        if !subscription.name.isEmpty && !subscription.address.isEmpty {
            subscription.enabled = true  // mihomo ÁöÑËÆ¢ÈòÖÈªòËÆ§ÂêØÁî®
            return subscription
        }
        
        return nil
    }
    
    // Êõ¥Êñ∞ MihomoTProxy ËÆ¢ÈòÖ
    func updateMihomoTProxySubscription(_ subscriptionId: String) async throws -> ConfigSubscription? {
        logger.info("ÂºÄÂßãÊõ¥Êñ∞ Nikki ËÆ¢ÈòÖ: \(subscriptionId)")
        
        let token = try await getAuthToken()
        
        let scheme = server.openWRTUseSSL ? "https" : "http"
        guard let openWRTUrl = server.openWRTUrl else {
            throw NetworkError.invalidURL
        }
        let baseURL = "\(scheme)://\(openWRTUrl):\(server.openWRTPort ?? "80")"
        guard let url = URL(string: "\(baseURL)/cgi-bin/luci/rpc/sys?auth=\(token)") else {
            throw NetworkError.invalidURL
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("sysauth=\(token); sysauth_http=\(token); sysauth_https=\(token)", forHTTPHeaderField: "Cookie")
        
        let command: [String: Any] = [
            "id": 1,
            "method": "exec",
            "params": ["/usr/libexec/\(packageName)-call subscription update \(subscriptionId)"]
        ]
        // print(command)
        request.httpBody = try JSONSerialization.data(withJSONObject: command)
        
        let (data, response) = try await URLSession.secure.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse,
              httpResponse.statusCode == 200 else {
            throw NetworkError.serverError(500)
        }
        
        let uciResponse = try JSONDecoder().decode(UCIResponse.self, from: data)
        if let error = uciResponse.error, !error.isEmpty {
            throw NetworkError.serverError(500)
        }
        
        // Á≠âÂæÖ3Áßí
        try await Task.sleep(nanoseconds: 3_000_000_000)
        
        // Ëé∑ÂèñÊõ¥Êñ∞ÂêéÁöÑËÆ¢ÈòÖ‰ø°ÊÅØ
        return try await fetchSubscriptionDetail(subscriptionId)
    }
    
    // Êõ¥Êñ∞Âçï‰∏™ OpenClash ËÆ¢ÈòÖ
    func updateOpenClashSubscription(_ subscription: ConfigSubscription) async throws {
        let token = try await getAuthToken()
        
        let scheme = server.openWRTUseSSL ? "https" : "http"
        guard let openWRTUrl = server.openWRTUrl else {
            throw NetworkError.invalidURL
        }
        let baseURL = "\(scheme)://\(openWRTUrl):\(server.openWRTPort ?? "80")"
        let timestamp = Int(Date().timeIntervalSince1970 * 1000)
        guard let url = URL(string: "\(baseURL)/cgi-bin/luci/admin/services/openclash/update_config?filename=\(subscription.name)&\(timestamp)") else {
            throw NetworkError.invalidURL
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.setValue("*/*", forHTTPHeaderField: "Accept")
        request.setValue("no-cache", forHTTPHeaderField: "Cache-Control")
        request.setValue("no-cache", forHTTPHeaderField: "Pragma")
        request.setValue("sysauth_http=\(token); sysauth_https=\(token)", forHTTPHeaderField: "Cookie")
        
        let (_, response) = try await URLSession.secure.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse,
              httpResponse.statusCode == 200 else {
            throw NetworkError.serverError(500)
        }
        
        // Á≠âÂæÖ3Áßí
        try await Task.sleep(nanoseconds: 3_000_000_000)
        
        // ÈáçÊñ∞Âä†ËΩΩËÆ¢ÈòÖÂàóË°®
        await loadSubscriptions()
    }
}
